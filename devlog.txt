>>> Plug and Play and IDE native mode (July 16)

When I ran Windows 95 in Qemu and looked at the registry, it showed PNPBIOS codes. The DS and SS segment cache did not have the BIG bit enabled (I think). This indicates the W95 is using a
separate stack segment to call the BIOS because the D/S bit is the only way for the BIOS to detect a 32-bit stack. Qemu reports specification-required PNP calls as unimplemented when using the real mode
interface. This suggests that W95 is using the 16-bit PM interface successfully on QEMU as there is no other way for it to get those codes. I do not have the W95 HD IMG atm and cannot download it now.

On the OSDev forum, a user said that the legacy 14/15 IRQs are not garaunteed to be configured by the BIOS for IDE native mode only controllers and can be set to whatever the BIOS likes (unlikely?). How should PCI.DRV
handle IDE controllers? Should native-only controller be reconfigured and how? One possibility it to overlap it with the PC/AT assignments. Regardless, I will have to depend on the resources being PC standard
by default before a PCI IDE driver can loaded by the built-in one.

>> 2022-07-29

I have decided to GPL this code. I must move the msdos.img file because it
contains proprietary software by Microsoft.

Q: Can devices know when an interrupt has completed, or does it merely recieve an acknowledgement?
A: Probably not?

One idea that I have is to send EOI right away along with STI. This will cause all interrupts to go through at any time outside a critical section. IRQ#0 would require special handling as there is no kernel pre-emtion.
This would cause everything to be slowed down. Sending EOI at the wrong time could also cause spurious interrupts.

Assuming that the device probably does not know the status of the interrupt (and can only be acknowledged), I can still implement the message system by sending EOI at the end of the master dispatcher and simply sending
the appropriate IRQ message.

Another idea is to not use messages to signal interrupts at all. This would be faster and I do not have to change existing code. The message intr idea may a gimmick without any practical use that only complicates things.
For example, to safely reboot or power off the computer, should I send a message to handle all inbound interrupts?
Many devices send interrupts only when a certain command is issued and do not send them constantly. Queuing would be useless and potentially impossible for interrupts.

In case it comes up, handling IRQs in user mode is not natively supported by x86 (or any architecture) and requires switching context on top of multiple function calls. It is useless.

Decision: I will remove IRQ messages from the documentation. Mbx is supposed by be like Unix /dev files and signals. Queuing will remain as it has value for userspace programs.


